###### tags: `JS`
# 二維陣列應用題：陣列旋轉

二維陣列簡單理解為一個陣列中的值有陣列型態
簡單的例子
```
const array = [[1,2,3],[4,5,6],[7,8,9]]
console.log(array[0][1])  //2
console.log(array[2][2])  //9
```

可以應用在一個有趣的試題
```
將 
1,2,3
4,5,6
7,8,9

旋轉90度
7,4,1
8,5,2
9,6,3
```
### 方法一：陣列轉置後再倒轉（reverse）
```
const array = [[1,2,3],[4,5,6],[7,8,9]]
const newArray = [];

//進行轉置
for(let i = 0; i<array[0].length ; i++){
    newArray[i]=[];
        for(let j = 0 ; j<array.length ; j++){
            newArray[i][j]=array[j][i];
        }
}
console.log(newArray) 
// [[1,4,7],
//  [2,5,8],
//  [3,6,9]

//再倒轉
for(let i =0;i<newArray.length; i++){
    newArray[i].reverse();
}
console.log(newArray)
// [7,4,1]
// [8,5,2]
// [9,6,3]
```

#### 思路

```
//原本的array
[1,2,3]
[4,5,6]
[7,8,9]
```
先將陣列轉置為：
```
//newArray
[1,4,7]
[2,5,8]
[3,6,9]
```
#### 轉置的步驟拆解：
觀察`newarray`的**第[0]列**中**值**的順序就是`array`的每**列**中的**第[0]的值**
第[0]列中有幾個值，等於迴圈要跑幾次(第[0]列的長度)
```
for(let i=0 ; i<array[0].length; i++)
```
此時`i`從0開始，
定義`newArray`的第[0]列中的值為陣列型態
```
newArray[i] = [];
```

開始為`newArray`**第[0]列**賦值
`array`本身陣列中有幾個值，等於迴圈要跑幾次
```
for(let j=0 ; j<array.length ; j++ ){
    newArray[i][j] = array[j][i]
}
```


```
//組合
for(let i = 0; i<array[0].length ; i++){
    newArray[i]=[];
        for(let j = 0 ; j<array.length ; j++){
            newArray[i][j]=array[j][i];
        }
}
```
//依執行步驟演示一次,`i`,`j`直接以數字表示
```
//array[0].length = 3;
//array.length = 3;
for(let i = 0 ; i<3 ; i++){
    newArray[0] = [];
        for(let j=0 ; j<3 ; j++ ){
            newArray[0][0] = array[0][0]
        }
}
//繼續...
//i = 0 , j = 0+1 = 1
newArray[0][1] = array[1][0];
//i = 0 , j = 1+1 = 2
newArray[0][2] = array[2][0]; 
//i = 0 , j = 2+1 = 3 ; 3<3為false，j迴圈結束，i迴圈執行i++
//i = 0+1 = 1 , j = 0
newArray[1][0] = array[0][1];
//i = 0+1 = 1 , j = 0 + 1 = 1
newArray[1][1] = array[1][1];
.
.
.
//i = 2 , j = 1
newArray[2][1] = array[1][2];
//i = 2 , j = 2
newArray[2][2] = array[2][2];
//-------
//轉置完成，喜獲newArray
//[1,4,7]
//[2,5,8]
//[3,6,9]
```

再用reverse掉換順序
```
for(let i =0;i<newArray.length; i++){
    newArray[i].reverse();
}
//調換完成，newArray再次變身
//[7,4,1]
//[8,5,2]
//[9,6,3]
```

DD後記：
沒有發現向右轉90度的呈現會和**轉置再調換**的一樣，其實一開始想的是方法二


### 方法二

```
array = 
[[1,2,3],
[4,5,6],
[7,8,9]]
//向右轉90度變成
newArray =
[[7,4,1],
[8,5,2],
[9,6,3]]
```
觀察array及要轉90度的newArray的規律

newArray裡的第[0]組陣列
newArray[0][0] = array[2][0]
newArray[0][1] = array[1][0]
newArray[0][2] = array[0][0]

newArray裡的第[1]組陣列（
newArray[1][0] = array[2][1]
newArray[1][1] = array[1][1]
newArray[1][2] = array[0][1]

newArray裡的第[2]組陣列
newArray[2][0] = array[2][2]
newArray[2][1] = array[1][2]
newArray[2][2] = array[0][2]

懶人包說明：
`newArray`第[0]列裡的值，等於`array`第[2][1][0]列中第[0]個值
`newArray`第[1]列裡的值，等於`array`第[2][1][0]列中第[1]個值
`newArray`第[2]列裡的值，等於`array`第[2][1][0]列中第[2]個值

~~有比較好嗎？~~

先以i, j分別替代值，會發現有這樣的規律：
newArray[ i ][ j ] = array[array.lenth -1 - j ][ i ]
`[arrary.lenth -1 - j]`會有點不直觀，必須一直找規律

其他迴圈跑的方式和**方法一**一樣，差別在不用再`reverse()`

```
var array = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];
const newArray = [];
var len = array.length;

for (let i = 0; i < array[0].length; i++) {
  newArray[i] = [];
  for (let j = 0; j < array.length; j++) {
    newArray[i][j] = array[len - 1 - j][i];
  }
}
console.log(newArray)
//[7,4,1]
//[8,5,2]
//[9,6,3]
//完成任務！！
```

備註
--
1. console.log出來會是一整列呈現，在此不多討論如何換行
2. 對`[arrary.lenth -1 - j]`有好的解釋歡迎告訴我～

參考
--
[【JS】轉置矩陣 #陣列](https://www.itread01.com/content/1542810303.html)












